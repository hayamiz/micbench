#!/usr/bin/env ruby

require 'optparse'

$procs = `cat /sys/devices/system/cpu/cpu*/topology/physical_package_id|sort|uniq|wc -l`.to_i
$logicores = `grep 'processor' /proc/cpuinfo|sort|uniq|wc -l`.to_i
$physcores_per_proc = `grep 'core id' /proc/cpuinfo|sort|uniq|wc -l`.to_i
$logicores_per_proc = $logicores / $procs
$nodes = `numactl --hardware|grep available`.split[1].to_i

class BaseCommand
  class << self
    def commands
      @@commands
    end

    @@commands = {}
    def command_name(name)
      @@commands[name] = self
    end
  end
end

class MemLatency < BaseCommand
  command_name "memlatency"
end

def print_usage()
  print <<EOS
Usage: #{$0} \x1b[4mcommand\x1b[0m [options]
EOS
end

def parse_size(sz_str)
  if sz_str =~ /\A(\d+)([kKmMgG]?)[bB]?\Z/
    size = $~[1].to_i
    sz_prefix = $~[2]
    case sz_prefix
    when /\A[kK]\Z/
      size *= 1024
    when /\A[mM]\Z/
      size *= 1024 * 1024
    when /\A[gG]\Z/
      size *= 1024 * 1024 * 1024
    end

    size
  else
    nil
  end
end


#
# Format of affinity description
#
# <affinity> := <entry> ['+' <affinity>]
# <entry> := <threads> ':' <CPU_assignment> [':' <mem_assignment>]
# <threads> := <thread_ids> [',' <threads>]
# <thread_ids> := <thread_id> ['-' <thread_id>]
# <CPU_assignment> := <unit_ids> [',' <CPU_assignment>]
# <unit_ids> := <core_ids> | <node_ids>
# <core_ids> := 'c' <core_id> ['-' <core_ids>]
# <node_ids> := 'n' <node_id> ['-' <node_ids>]
# <mem_assignment> := <node_ids> [',' <mem_assignment>]
#

# parse affinity description and return a Hash:
#   key  : THREAD_ID (Integer)
#   value: [Array of CPU_ID (Integer)] or [Array of CPU_ID (Integer), Array of MEMORY_NODE_ID (Integer)]

def parse_affinity(aff_str)
  def parse_threads(threads_str)
    unless threads_str =~ /\A\d+(-\d+)?(,\d+(-\d+)?)*\Z/
      raise ArgumentError.new("Invalid threads: #{threads_str}")
    end
    threads_str.split(",").map do |thread_ids_str|
      parse_ids(thread_ids_str)
    end.flatten.sort.uniq
  end

  def parse_cpu_assignment(cpu_str)
    unless cpu_str =~ /\A([cn]\d+(?:-\d+)?)(,[cn]\d+(?:-\d+)?)*\Z/
      raise ArgumentError.new("Invalid cpu assignment: #{cpu_str}")
    end
    if cpu_str.nil?
      return (0..($logicores - 1)).to_a
    end
    cpu_str.split(",").map do |unit_str|
      if unit_str[0] == "c"
        parse_ids(unit_str, "c")
      elsif unit_str[1] == "n"
        node_ids = parse_ids(unit_str, "c")
        node_ids.map do |node_id|
          cpuid = $logicores_per_proc * node_id
          (cpuid..(cpuid + $logicores_per_proc - 1)).to_a
        end.flatten.sort.uniq
      end
    end.flatten.sort.uniq
  end

  def parse_mem_assignment(mem_str)
    unless mem_str =~ /\A\d+(-\d+)?(,\d+(-\d+)?)*\Z/
      raise ArgumentError.new("Invalid memory assignment: #{mem_str}")
    end
    if mem_str.nil?
      return (0..($nodes - 1)).to_a
    end
    mem_str.split(",").map do |mem_ids|
      parse_ids(mem_ids)
    end.flatten.sort.uniq
  end

  def parse_ids(ids_str, prefix = '')
    unless prefix.size == 0 || Regexp.compile("^" + Regexp.quote(prefix)) =~ ids_str
      raise ArgumentError.new("Invalid ids: #{ids_str}")
    end
    unless ids_str =~ /\A#{Regexp.quote(prefix)}\d+(-\d+)?\Z/
      raise ArgumentError.new("Invalid ids: #{ids_str}")
    end
    if prefix.size > 0
      ids_str = ids_str[(prefix.size)..(ids_str.size - 1)]
    end
    id1, id2 = ids_str.split("-")
    id1 = id1.to_i
    if id2.nil?
      id1
    else
      id2 = id2.to_i
      if id2 < id1
        tmp = id2
        id1 = id2
        id2 = tmp
      end
      (id1..id2).to_a
    end
  end

  thread_masks = Hash.new

  aff_str.split('+').each do |entry|
    threads, *rest = entry.split(":")
    if rest.size < 1 || rest.size > 2
      raise ArgumentError.new("Invalid affinity description: #{aff_str}")
    end
    cpu_assign, mem_assign = *rest

    thread_id_set = parse_threads(threads)
    cpu_id_set = parse_cpu_assignment(cpu_assign)
    memnode_id_set = parse_mem_assignment(mem_assign)

    thread_id_set.each do |tid|
      thread_masks[tid] = [cpu_id_set, memnode_id_set]
    end
  end

  thread_masks
end

def io_main(argv)
  def io_parse_args(argv)
    opt = Hash.new
    parser = OptionParser.new

    parse_error = lambda do |*msg|
      if msg.size > 0
        msg.each do |m|
          $stderr.puts("#{$0}: #{m}")
        end
      end
      puts parser.help
      exit(false)
    end

    # argv[1]
    opt[:noop] = false
    parser.on('-n', '--noop',
              "Dry-run if this option is specified.") do
      opt[:noop] = true
    end

    # argv[2]
    opt[:multi] = 1
    parser.on('-m', '--multi NUM', Integer,
              "The number of IO threads (default: 1)") do |num|
      opt[:multi] = num
    end

    # argv[3]
    opt[:affinity] = false
    parser.on('-a', '--affinity AFFINITY',
              "CPU and memory affinity setting") do |affinity|
      opt[:affinity] = parse_affinity(affinity)
    end

    # argv[4]
    opt[:timeout] = 60
    parser.on('-t', '--timeout NUM',
              "Running time of IO test (in sec) (default: 60sec)") do |num|
      if num =~ /\A\d+\Z/
        opt[:timeout] = num.to_i
      else
        parse_error.call("--timeout requires positive integer.")
      end
    end

    # argv[5]
    opt[:mode] = :read
    parser.on('-w', '--write',
              "Write operation (default: read operation)") do
      opt[:mode] = :write
    end

    # argv[6]
    opt[:pattern] = :seq
    seq_specified = false
    rand_specified = false
    parser.on('-S', '--seq',
              "Sequential access mode (default mode)") do
      seq_specified = true
      opt[:pattern] = :seq
    end
    parser.on('-R', '--rand',
              "Random access mode (default: sequential access mode)") do
      seq_specified = true
      opt[:pattern] = :rand
    end

    # argv[7]
    opt[:direct] = false
    parser.on('-d', '--direct',
              "Use O_DIRECT (default: no). If this flag is specified, block size must be multiples of block size of devices.") do
      opt[:direct] = true
    end

    # argv[8]
    opt[:blocksize] = 16 * 1024
    parser.on('-b', '--blocksize SIZE',
              "Size of IO block (default: 16k)") do |size|
      unless opt[:blocksize] = parse_size(size)
        parse_error.call("invalid argument for --size: #{size}")
      end
    end

    # argv[9]
    opt[:offset_start] = 0
    parser.on('-s', '--offset-start OFFSET',
              "Offset (in blocks) to start with (default: 0)") do |offset|
      if offset =~ /\A\d+\Z/
        opt[:offset_start] = offset.to_i
      else
        parse_error.call("--offset-start requires 0 or positive integer.")
      end
    end

    # argv[10]
    opt[:offset_end] = 0
    parser.on('-s', '--offset-end OFFSET',
              "Offset (in blocks) to end with (default: the size of device)") do |offset|
      if offset =~ /\A\d+\Z/
        opt[:offset_end] = offset.to_i
      else
        parse_error.call("--offset-end requires 0 or positive integer.")
      end
    end

    # argv[11]
    opt[:misalign] = 0
    parser.on('-M', '--misalign OFFSET',
              "Misalignment from current position (in byte) (default: 0)") do |offset|
      if offset =~ /\A\d+\Z/
        opt[:misalign] = offset.to_i
      else
        parse_error.call("--misalign requires 0 or positive integer.")
      end
    end

    # argv[12]
    opt[:verbose] = false
    parser.on('-v', '--verbose') do
      opt[:verbose] = true
    end

    parser.parse!(argv)

    if seq_specified && rand_specified
      parse_error.call("--seq and --rand cannot be specified at a time")
      parse_error.call
    end

    # TODO: parse affinity

    opt
  end

  opt = io_parse_args(argv)

  command = File.join(File.dirname(__FILE__), "micbench-io")
  command_str = [command,
                 opt[:noop],
                 opt[:multi],
                 opt[:affinity],
                 opt[:timeout],
                 opt[:mode],
                 opt[:pattern],
                 opt[:direct],
                 opt[:blocksize],
                 opt[:offset_start],
                 opt[:offset_end],
                 opt[:misalign],
                 opt[:verbose]].join(" ")

  if ENV['MB_DEBUG']
    puts command_str
  end
  if ENV['MB_LEAKCHECK']
    command_str = "valgrind --leak-check=full " + command_str
  end
  exec(command_str)
end

def mem_main(argv)
  def mem_parse_args(argv)
    opt = Hash.new
    parser = OptionParser.new

    parse_error = lambda do |*msg|
      if msg.size > 0
        msg.each do |m|
          $stderr.puts("#{$0}: #{m}")
        end
      end
      puts parser.help
      exit(false)
    end

    # argv[1]
    opt[:multi] = 1
    parser.on('-m', '--multi NUM', Integer,
              "Multiplicity of memory access (default: 1)") do |num|
      opt[:multi] = num
    end

    # argv[2]
    opt[:timeout] = 60
    parser.on('-t', '--timeout NUM',
              "Running time of memory access test (in sec) (default: 60sec)") do |num|
      if num =~ /\A\d+\Z/
        opt[:timeout] = num.to_i
      else
        parse_error.call("--timeout requires positive integer.")
      end
    end

    # argv[3]
    opt[:mode] = :seq
    seq_specified = false
    rand_specified = false
    parser.on('-S', '--seq',
              "Sequential memory access mode (default mode)") do
      seq_specified = true
      opt[:mode] = :seq
    end
    parser.on('-R', '--rand',
              "Random memory access mode (default: sequential access mode)") do
      seq_specified = true
      opt[:mode] = :rand
    end

    # argv[4]
    opt[:local] = false
    parser.on('-L', '--local',
              "Allocate separated memory region for each thread (default: sharing one region)") do
      opt[:local] = true
    end

    # argv[5]
    opt[:affinity] = false
    parser.on('-a', '--affinity AFFINITY',
              "CPU and memory utilization policy") do |affinity|
      opt[:affinity] = affinity
    end

    # argv[6]
    opt[:size] = 2 ** 20
    parser.on('-s', '--size SIZE',
              "Size of memory region (default: 1MB)") do |size|
      unless opt[:size] = parse_size(size)
        parse_error.call("invalid argument for --size: #{size}")
      end
    end

    # argv[7]
    opt[:hugetlbfile] = false
    parser.on('-H', '--hugetlbfile PATH',
              "Use HugePages if specified. Give a path to file on hugetlbfs.") do |path|
      # TODO: more strict check
      unless File.exists?(path)
        parse_error.call("no such file: #{path}")
      end
      opt[:hugetlbfile] = path
    end

    # argv[8]
    opt[:hugepagesize] = 2 * 2**20
    parser.on('-z', '--hugepagesize SIZE',
              "Size of HugePage (default: 2MB)") do |size|
      # TODO: more strict check
      unless opt[:hugepagesize] = parse_size(size)
        parse_error.call("invalid argument for --hugepagesize: #{size}")
      end
    end

    # argv[9]
    opt[:verbose] = false
    parser.on('-v', '--verbose') do
      opt[:verbose] = true
    end

    parser.parse!(argv)

    if seq_specified && rand_specified
      parse_error.call("--seq and --rand cannot be specified at a time")
      parse_error.call
    end

    # TODO: parse affinity

    opt
  end

  opt = mem_parse_args(argv)

  command = File.join(File.dirname(__FILE__), "micbench-mem")
  command_str = [command,
                 opt[:multi],
                 opt[:timeout],
                 opt[:mode],
                 opt[:local],
                 opt[:affinity],
                 opt[:size],
                 opt[:hugetlbfile],
                 opt[:hugepagesize],
                 opt[:verbose]].join(" ")

  if ENV['MB_DEBUG']
    puts command_str
  end
  if ENV['MB_LEAKCHECK']
    command_str = "valgrind --leak-check=full " + command_str
  end
  exec(command_str)
end

def main(argv)
  if argv.size > 0
    command = argv.shift
    case command
    when "mem"
      mem_main(argv)
    else
      puts "#{$0}: Unknown command '#{command}'"
    end
  else
    print_usage()
    exit(false)
  end
end

if __FILE__ == $0
  main(ARGV.dup)
end
