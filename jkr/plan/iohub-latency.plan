# -*- mode: ruby -*-

title "Measure IO performance"
description "Measure IO performance"

require 'yaml'

def system_(*args)
  puts "system_: #{args.join(' ')}"
  unless system(*args)
    raise RuntimeError.new(args.join(" "))
  end
end

def_parameters do
  parameter :command => "./src/micbench-io"

  parameter :blocksize => 512
  # variable :pattern => [:sequential, :random]
  parameter :pattern => :sequential
  parameter :mode => :read # [:read, :write]

  parameter :multiplicity => 1

  nodes = `numactl --show|grep membind|sed -e 's/^membind: //g'`.strip.split.map(&:to_i)
  variable :cpunode => nodes

  parameter :device => "sdb"
  parameter :direct_io => true
  parameter :timeout => 30
  parameter :offset_start => 0
  parameter :offset_end => 1
  parameter :use_systemtap => false

  # interval of monitoring system state in second
  # metrics: disk io, cpu usage, ...
  parameter :sys_monitor_interval => 1

  parameter :short_hostname => `hostname -s`.strip
end

def_prep do |plan|
  $debugfs_path = '/sys/kernel/debug'
  if File.exists?($debugfs_path)
    $debugfs_mounted = true
    puts "debugfs ready"
  else
    $debugfs_mounted = false
    puts "debugfs not ready"
    system_("mount -t debugfs debugfs #{$debugfs_path}")
  end

  ENV['LD_LIBRARY_PATH'] = [ENV['LD_LIBRARY_PATH'],
                            File.join('/home', 'haya',
                                      plan.params[:short_hostname],
                                      "usr", "lib")].join(":")
  ENV['LANG'] = "C"
  
  # warming up
  # system_("./bin/memstress", "-s", "1G", "-m", SysUtils.num_cores.to_s,
  #         "-t", plan.params[:duration].to_s, "-L")
end

def_routine do |plan, params|
  ENV['LANG'] = "C"
  # Cpufreq::Config.set(Cpufreq::Config.new(:governor => :performance))

  env_dump = Hash.new
  env_dump[:num_processor] = SysUtils.num_processors
  env_dump[:num_cores] = SysUtils.num_cores

  params[:device_or_file] = "/dev/#{params[:device]}"

  system_("echo noop > /sys/block/#{params[:device]}/queue/scheduler")
  system_("#{params[:command]} --direct -t 5 -b 64k -m 32 --rand -v #{params[:device_or_file]} # disturb cache")

  FileUtils.mkdir_p(result_file_name("blktrace"))

  begin
    printf("multi: %d, mode: %s, pattern %s, blocksize: %s\n",
           params[:multiplicity],
           params[:mode],
           params[:pattern],
           params[:blocksize])
    monitor_times = ((params[:timeout] + 2) / params[:sys_monitor_interval]).to_i

    if params[:use_systemtap]
      stap_pid = Process.spawn(["stap", "stap/iotrace.stp",
                                (params[:timeout] + 5).to_s, params[:device],
                                ">", touch_result_file("iotrace.txt")].join(" "))
      sleep(1)
    else
      stap_pid = nil
    end

    params[:num_cores] = `grep 'core id' /proc/cpuinfo|sort|uniq|wc -l`.to_i
    params[:num_processors] = `grep 'physical id' /proc/cpuinfo|sort|uniq|wc -l`.to_i
    params[:num_logical_cpus] = `grep 'processor' /proc/cpuinfo|sort|uniq|wc -l`.to_i
    params[:num_logical_cores] = params[:num_logical_cpus] / params[:num_processors]

    with_process2("mpstat", "-P", "ALL",
                  params[:sys_monitor_interval],
                  monitor_times, " > ", touch_result_file("mpstat.txt")) do
      with_process2("iostat", "-d", "-x", "-k", "-t",
                    params[:sys_monitor_interval],
                    monitor_times, " > ", touch_result_file("iostat.txt")) do
        params[:start_time] = Time.now
        args = [params[:command]]
        args += ["--multi", params[:multiplicity]]
        if params[:mode] == :write
          args += ["--write"]
        end
        if params[:pattern] == :random
          args += ["--rand"]
        end

        raise StandardError.new(":cpunode required.") unless params[:cpunode]
        cpuid = params[:cpunode] * params[:num_logical_cores]
        params[:thread_affinity] = "0:#{cpuid}:#{params[:cpunode]}"
        args += ["-A", params[:thread_affinity]]

        args += ["--blocksize", params[:blocksize]]
        if params[:direct_io]
          args += ["--direct"]
        end
        if params[:offset_start]
          args += ["--offset-start", params[:offset_start]]
        end
        if params[:offset_end]
          args += ["--offset-end", params[:offset_end]]
        end
        args += ["--timeout", params[:timeout]]
        args += [params[:device_or_file]]

        blktrace_pid = Process.spawn("blktrace -a complete -a issue -w #{params[:timeout]} -D #{result_file_name("blktrace")} -d #{params[:device_or_file]}")
        system_(args.join(" ") + " > #{result_file_name('iostress.txt')}")
        params[:end_time] = Time.now
        Process.waitpid(blktrace_pid)
      end
    end

    if stap_pid
      Process.waitpid(stap_pid)
    end

    env_dump[:params] = params
    with_result_file("env_dump.marshal") do |f|
      Marshal.dump(env_dump, f)
    end

    puts "Finished"
  rescue Exception => err
    puts "Error"
    errmsg = sprintf("%s: %s\n%s",
                     err.class.to_s, err.message,
                     err.backtrace.join("\n"))
    send_mail("[error report] #{plan.title}",
              ["hayamiz.mobi@gmail.com"],
              errmsg + "\n\n" + params.inspect)
    exit(1)
  end
  FileUtils.chown_R(ENV['USER'], nil, [File.dirname(result_file_name("foo"))],
                    :verbose => true)
end

def send_mail(subject, addrs, body, files = [])
  attach_option = files.map{|file| "-a #{file}"}.join(" ")
  IO.popen("mutt #{addrs.join(' ')} -s #{subject.inspect} #{attach_option}", "w+") do |io|
    io.puts body
  end
end

def_cleanup do |plan|
  if $debugfs_mounted == false
    system_("umount #{$debugfs_path}")
  end
  send_mail("[report] #{plan.title}",
            ["hayamiz.mobi@gmail.com"],
            "finished")
  FileUtils.chown_R(ENV['USER'], nil, [plan.jkr_env.jkr_result_dir],
                    :verbose => true)
end

def_analysis do |plan|
  use_script :iohub_latency
  iohub_latency_analyze(plan)
end

def h(num)
  if num < 2 ** 10
    num.to_s+"B"
  elsif num < 2 ** 20
    (num / 2**10).to_s+"KB"
  elsif num < 2 ** 30
    (num / 2**20).to_s+"MB"
  else num < 2 ** 40
    (num / 2**30).to_s+"GB"
  end
end
