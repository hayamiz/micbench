# -*- mode: ruby -*-

title "IO measurements for Multiple Devices"
description "Measure IO performance"

def system_(*args)
  puts "system_: #{args.join(' ')}"
  unless system(*args)
    raise RuntimeError.new(args.join(" "))
  end
end

def_parameters do
  variable :blocksize => [4 * 1024]
  variable :pattern => [:random, :sequential]
  variable :mode => [:read] # [:read, :write]
  variable :multiplicity => (1..32).to_a

  # variable :devices => (1..20).map{|num_dev|
  #   devices = ("b".."u").map{|devchar| "sd#{devchar}"}
  #   devices.first(num_dev)
  # }
  parameter :devices => ("b".."u").map{|devchar| "sd#{devchar}"}

  parameter :direct_io => true
  parameter :timeout => 30
  parameter :use_systemtap => false
  parameter :affinity => nil # "0-31:n2:0"

  # parameter :use_blktrace => true
  parameter :use_blktrace => false
  # TODO: check debugfs and mount on demand

  # interval of monitoring system state in second
  # metrics: disk io, cpu usage, ...
  parameter :sys_monitor_interval => 1

  parameter :short_hostname => `hostname -s`.strip

  parameter :email => "hayamiz.mobi@gmail.com"
end

def_prep do |plan|
  ENV['LD_LIBRARY_PATH'] = [ENV['LD_LIBRARY_PATH'],
                            File.join('/home', 'haya',
                                      plan.params[:short_hostname],
                                      "usr", "lib")].join(":")
  ENV['LANG'] = "C"

  # warming up
  # system_("./bin/memstress", "-s", "1G", "-m", SysUtils.num_cores.to_s,
  #         "-t", plan.params[:duration].to_s, "-L")
end

def_routine do |plan, params|
  ENV['LANG'] = "C"
  Cpufreq::Config.set(Cpufreq::Config.new(:governor => :performance))

  env_dump = Hash.new
  env_dump[:num_processor] = SysUtils.num_processors
  env_dump[:num_cores] = SysUtils.num_cores

  if params[:use_blktrace]
    FileUtils.mkdir_p(result_file_name("blktrace"))
  end

  params[:devices].each do |dev|
    system_("echo noop > /sys/block/#{dev}/queue/scheduler")
  end

  begin
    printf("multi: %d, mode: %s, pattern %s, blocksize: %s\n",
           params[:multiplicity],
           params[:mode],
           params[:pattern],
           params[:blocksize])
    monitor_times = ((params[:timeout] + 2) / params[:sys_monitor_interval]).to_i

#     if params[:use_systemtap]
#       stap_pid = Process.spawn(["stap", "stap/iotrace.stp",
#                                 (params[:timeout] + 5).to_s, params[:device],
#                                 ">", touch_result_file("iotrace.txt")].join(" "))
#       sleep(1)
#     else
#       stap_pid = nil
#     end

    with_process2("mpstat", "-P", "ALL",
                  params[:sys_monitor_interval],
                  monitor_times, " > ", touch_result_file("mpstat.txt")) do
      with_process2("iostat", "-d", "-x", "-k", "-t",
                    params[:sys_monitor_interval],
                    monitor_times, " > ", touch_result_file("iostat.txt")) do
        params[:start_time] = Time.now
        args = ["./src/micbench", "io"]
        args += ["--multi", params[:multiplicity]]
        if params[:mode] == :write
          args += ["--write"]
        end
        if params[:pattern] == :random
          args += ["--rand"]
        end
        args += ["--blocksize", params[:blocksize]]
        if params[:direct_io]
          args += ["--direct"]
        end
        args += ["--timeout", params[:timeout]]
        if params[:affinity]
          args += ["--affinity", params[:affinity]]
        end

        FileUtils.mkdir_p(rname('iostress'))
        micbench_pids = []
        params[:devices].each do |dev|
          local_args = args + ["/dev/#{dev}"]
          command = local_args.join(" ") + " > #{rname('iostress/'+dev+'.txt')}"
          puts command
          pid = Process.spawn(command)
          micbench_pids.push(pid)
        end

        micbench_pids.each{|pid| Process.waitpid(pid)}
        params[:end_time] = Time.now
      end
    end

#     if stap_pid
#       Process.waitpid(stap_pid)
#     end

    env_dump[:params] = params
    with_result_file("env_dump.marshal") do |f|
      Marshal.dump(env_dump, f)
    end

    puts "Finished"
  rescue Exception => err
    puts err.message
    puts err.backtrace
    errmsg = sprintf("%s: %s\n%s",
                     err.class.to_s, err.message,
                     err.backtrace.join("\n"))
    send_mail("[error report] #{plan.title}",
              [params[:email]],
              errmsg + "\n\n" + params.inspect)
    exit(1)
  end
  FileUtils.chown_R(ENV['USER'], nil, [File.dirname(result_file_name("foo"))],
                    :verbose => true)
end

def send_mail(subject, addrs, body, files = [])
  attach_option = files.map{|file| "-a #{file}"}.join(" ")
  IO.popen("mutt #{addrs.join(' ')} -s #{subject.inspect} #{attach_option}", "w+") do |io|
    io.puts body
  end
end

def_cleanup do |plan|
  send_mail("[report] #{plan.title}",
            [plan.params[:email]],
            "finished")
  FileUtils.chown_R(ENV['USER'], nil, [plan.jkr_env.jkr_result_dir],
                    :verbose => true)
end

def_analysis do |plan|
  use_script :mio_multi
  iostress_analyze(plan)
end

def h(num)
  if num < 2 ** 10
    num.to_s+"B"
  elsif num < 2 ** 20
    (num / 2**10).to_s+"KB"
  elsif num < 2 ** 30
    (num / 2**20).to_s+"MB"
  else num < 2 ** 40
    (num / 2**30).to_s+"GB"
  end
end
