# -*- mode: ruby -*-

title "Measure IO performance"
description "Measure IO performance"

require 'yaml'

def system_(*args)
  puts "system_: #{args.join(' ')}"
  unless system(*args)
    raise RuntimeError.new(args.join(" "))
  end
end

def_parameters do
  variable :blocksize => [512, 2**16]
  variable :pattern => [:random]
  variable :mode => [:read] # [:read, :write]
  # variable :multiplicity => (1..10).map{|x| 2**x}.shuffle # (1..64).to_a.shuffle
  # variable :multiplicity => (0..8).map{|x|
  #   base = 2**x
  #   sample = 2**([3,[0, x].max].min)
  #   ret = []
  #   sample.times{|y|
  #     ret.push(base + y * base / sample)
  #   }
  #   ret
  # }.flatten.shuffle
  variable :multiplicity => [1, 4, 16]

  variable :device => ["fioa", "fiob"]
  # variable :device => ["fioa", "fiob"]
  parameter :direct_io => true
  parameter :timeout => 30
  parameter :use_systemtap => false

  # parameter :use_blktrace => true
  variable :use_blktrace => [true, false]
  # TODO: check debugfs and mount on demand

  # interval of monitoring system state in second
  # metrics: disk io, cpu usage, ...
  parameter :sys_monitor_interval => 1

  parameter :short_hostname => `hostname -s`.strip

  parameter :email => "hayamiz.mobi@gmail.com"
end

def_prep do |plan|
  ENV['LD_LIBRARY_PATH'] = [ENV['LD_LIBRARY_PATH'],
                            File.join('/home', 'haya',
                                      plan.params[:short_hostname],
                                      "usr", "lib")].join(":")
  ENV['LANG'] = "C"

  # warming up
  # system_("./bin/memstress", "-s", "1G", "-m", SysUtils.num_cores.to_s,
  #         "-t", plan.params[:duration].to_s, "-L")
end

def_routine do |plan, params|
  ENV['LANG'] = "C"
  Cpufreq::Config.set(Cpufreq::Config.new(:governor => :performance))

  env_dump = Hash.new
  env_dump[:num_processor] = SysUtils.num_processors
  env_dump[:num_cores] = SysUtils.num_cores

  params[:device_or_file] = "/dev/#{params[:device]}"

  if params[:use_blktrace]
    FileUtils.mkdir_p(result_file_name("blktrace"))
  end

  system_("echo noop > /sys/block/#{params[:device]}/queue/scheduler")
  # system_("./src/micbench-io --direct -t 10 -b 64k -m 32 --rand -v #{params[:device_or_file]} # disturb cache")

  begin
    printf("multi: %d, mode: %s, pattern %s, blocksize: %s\n",
           params[:multiplicity],
           params[:mode],
           params[:pattern],
           params[:blocksize])
    monitor_times = ((params[:timeout] + 2) / params[:sys_monitor_interval]).to_i

    if params[:use_systemtap]
      stap_pid = Process.spawn(["stap", "stap/iotrace.stp",
                                (params[:timeout] + 5).to_s, params[:device],
                                ">", touch_result_file("iotrace.txt")].join(" "))
      sleep(1)
    else
      stap_pid = nil
    end

    with_process2("mpstat", "-P", "ALL",
                  params[:sys_monitor_interval],
                  monitor_times, " > ", touch_result_file("mpstat.txt")) do
      with_process2("iostat", "-d", "-x", "-k", "-t",
                    params[:sys_monitor_interval],
                    monitor_times, " > ", touch_result_file("iostat.txt")) do
        params[:start_time] = Time.now
        args = ["./src/micbench-io"]
        args += ["--multi", params[:multiplicity]]
        if params[:mode] == :write
          args += ["--write"]
        end
        if params[:pattern] == :random
          args += ["--rand"]
        end
        args += ["--blocksize", params[:blocksize]]
        if params[:direct_io]
          args += ["--direct"]
        end
        args += ["--timeout", params[:timeout]]

        args += [params[:device_or_file]]

        if params[:use_blktrace]
          blktrace_pid = Process.spawn("blktrace -a complete -a issue -w #{params[:timeout]} -D #{result_file_name("blktrace")} -d #{params[:device_or_file]}")
        else
          blktrace_pid = nil
        end

        system_(args.join(" ") + " > #{result_file_name('iostress.txt')}")
        params[:end_time] = Time.now

        if blktrace_pid
          Process.waitpid(blktrace_pid)
        end
      end
    end

    if stap_pid
      Process.waitpid(stap_pid)
    end

    env_dump[:params] = params
    with_result_file("env_dump.marshal") do |f|
      Marshal.dump(env_dump, f)
    end

    puts "Finished"
  rescue Exception => err
    puts "Error"
    errmsg = sprintf("%s: %s\n%s",
                     err.class.to_s, err.message,
                     err.backtrace.join("\n"))
    send_mail("[error report] #{plan.title}",
              [params[:email]],
              errmsg + "\n\n" + params.inspect)
    exit(1)
  end
  FileUtils.chown_R(ENV['USER'], nil, [File.dirname(result_file_name("foo"))],
                    :verbose => true)
end

def send_mail(subject, addrs, body, files = [])
  attach_option = files.map{|file| "-a #{file}"}.join(" ")
  IO.popen("mutt #{addrs.join(' ')} -s #{subject.inspect} #{attach_option}", "w+") do |io|
    io.puts body
  end
end

def_cleanup do |plan|
  send_mail("[report] #{plan.title}",
            [plan.params[:email]],
            "finished")
  FileUtils.chown_R(ENV['USER'], nil, [plan.jkr_env.jkr_result_dir],
                    :verbose => true)
end

def_analysis do |plan|
  use_script :io_multi
  iostress_analyze(plan)
end

def h(num)
  if num < 2 ** 10
    num.to_s+"B"
  elsif num < 2 ** 20
    (num / 2**10).to_s+"KB"
  elsif num < 2 ** 30
    (num / 2**20).to_s+"MB"
  else num < 2 ** 40
    (num / 2**30).to_s+"GB"
  end
end
